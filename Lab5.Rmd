---
title: "R Notebook"
authors: "Tori Hancheck and Sam Colucci"
output: html_notebook
---

# Problem 0

https://github.com/sam-colucci/ma350-lab5

# Problem 1

```{r}
x <- c(2.2, 7.8, -4.4, 0.0, -1.2, 3.9, 4.9, -5.7, -7.9, -4.9, 28.7, 4.9) # Given sample that we will be using, stored in variable x

first.quartile <- quantile(x)[[2]] # Calculate first quartile of x

first.quartile # Return first quartile value

third.quartile <- quantile(x)[[4]] # Calculate third quartile of x

third.quartile # Return third quartile

IQR <- third.quartile - first.quartile # Calculate Interquartile range

IQR # Return interquartile range
```
The first quartile is -4.525 and the third quartile is 4.900. The interquartile range is 9.425. These values are correct because, upon observing the sample values, about 25% of the sample values are less than -4.525, about 75% of the sample values are less than 4.9.  Since these values make sense, the interquartile range value of 4.90 - (-4.525) = 9.425 is also correct. 

# Problem 2

```{r}
#' Takes a vector containing a sample and returns a vector with
#' three components: the first quartile, the third quartile, and
#' the interquartile range
#'
#' @param v vector containing a sample
#' @return a vector with three components: the first quartile, the
#' third quartile, and the interquartile range

quartiles <- function (v) {
  y <- vector()
  y[1] <- quantile(v)[[2]]
  y[2] <- quantile(v)[[4]]
  y[3] <- y[2] - y[1]
  return(y)
}

quartiles(x) # Run function with x as input vector
```
The output for **x** is a vector with the elements -4.525, 4.900, and 9.425 which are the first quartile, third quartile, and IQR, respectively. Comparing these values to our answer in Problem 1, the function gives the correct output. 

# Problem 3

```{r}
quartiles(x)[[1]] - 1.5*quartiles(x)[[3]] # Calculate lower boundary for Tukey
quartiles(x)[[2]] + 1.5*quartiles(x)[[3]] # Calculate upper boundary for Tukey
```
The only outlier in **x** is 28.7, according to Tukey's rule.

# Problem 4

```{r}
#' Takes a vector containing a sample and returns a Boolean vector
#' with TRUE at the elements corresponding to outlier observations 
#' and FALSE everywhere else
#'
#' @param v vector containing a sample
#' @return Boolean vector with TRUE at the elements corresponding to
#' outlier observations and FALSE everywhere else

tukey.outlier <- function(v) {
  z <- vector()
  for (i in 1:length(v)){
  if ((v[i] < (quartiles(v)[[1]] - 1.5*(quartiles(v)[[3]]))) || (v[i] > (quartiles(v)[[2]] + 1.5*(quartiles(v)[[3]])))) {
    z[i] <- TRUE
  }
    else {
      z[i] <- FALSE
    }
  }
  return(z)
}

tukey.outlier(x) # Run function with x as input vector
```
For **x**, the function gives the correct output.

# Problem 5

```{r}
#' Tests tukey.outlier() against the answer to Problem 3
#'
#' @param fun a function to compute outliers, with tukey.outlier
#' as its default value
#' @return TRUE if the function correctly identifies the outliers
#' and FALSE otherwise

test.tukey.outlier <- function(fun = tukey.outlier)
 
```










